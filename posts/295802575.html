<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="description" content="zChange blog" />
<link rel="stylesheet" href="\css\style.css" />

<title>
原型 or 原型链 | zChange
</title>
</head>

<body>

<div class="header">
  <div class="center">
    <h1>
      <a href="\">zChange</a>
    </h1>
    <p>zChange blog</p>
    <div class="menu">
    
      <a href="\categories\">categories</a>
    
      <a href="\tags\">tags</a>
    
      <a href="\about\">about</a>
    
    </div>
  </div>
</div>



<div id="post" class="center">
  <h1>原型 or 原型链</h1>
  <p>
    <a href="https://github.com/zChanges">zChanges</a>
    Posted at
    February 09, 2018
    . - <a href="\categories\0\">uncategorized</a>
  </p>

  <div class="content"><h2 id="原型prototype">原型(prototype):</h2><p><strong>每个函数都有一个prototype属性，他是以对象形式存在的，可以在这个对象上添加属性和方法，通过这个函数创建的实例都会继承这些属性和方法。(函数才会有)</strong></p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre> <span class="hljs-comment">// 原型 prototype</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"></span>) </span>{} <span class="hljs-comment">// 通过构造函数创建的实例foo</span>
 Foo.prototype.name = <span class="hljs-string">'zz'</span>;
 <span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo();
 foo.name <span class="hljs-comment">// zz;</span>
 <span class="hljs-built_in">Object</span>.getPrototypeOf(foo) === Foo.protptype <span class="hljs-comment">// true   ES5</span>
 <span class="hljs-comment">// foo通过Foo创建的实例都继承Foo.prototype的属性和方法</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <h2 id="原型链proto">原型链(<em>proto</em>):</h2><p><strong>几乎所有对象都有一个与之对应的原型对象，<code>_proto_</code>属性值就是对应原型对象，用来继承原型中的属性和方法</strong>
<strong>实例中访问属性和方法都会先在自身查找，如果没有就会去原型中查找，而原型也有他自己的原型，这就形成了链式,直到返回null为结束.(几乎所有对象都有)</strong></p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre><span class="hljs-comment">// 原型链 _proto_</span>
<span class="hljs-variable">_proto_</span> 属性会指向该对象的原型。
foo.<span class="hljs-variable">_proto_</span> === Foo.prototype  <span class="hljs-comment">// true</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <h2 id="构造函数constructor">构造函数(constructor):</h2><p><strong>构造函数就是初始化一个实例对象。每个原型上都有一个constructor属性，指向关联的构造函数</strong>
<strong>判别一个是构造函数，可以通过这个函数是否实例化。</strong></p>

      <div class="hljs javascript">
        <table>
          <tbody>
            <tr>
              <td class="line">
                <pre><span>1</span>
</pre>
              </td>
              <td class="code"><pre> <span class="hljs-comment">// 构造函数Foo</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span> <span class="hljs-params">()</span> <span class="hljs-comment">{
 }</span>
 <span class="hljs-title">Foo</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">name</span> = '<span class="hljs-title">zz</span>';</span>
 <span class="hljs-comment">// 通过构造函数创建的实例foo</span>
 <span class="hljs-keyword">var</span> foo = new Foo();
 foo.<span class="hljs-keyword">name</span> <span class="hljs-comment">// zz;</span>
 <span class="hljs-comment">// foo继承构造函数Foo原型上的属性和方法</span>

Foo.prototype <span class="hljs-comment">// { constructor: Foo()  }</span>
Foo === Foo.prototype.<span class="hljs-keyword">constructor</span>  <span class="hljs-comment">// true</span>

foo.<span class="hljs-keyword">constructor</span> === Foo.prototype.<span class="hljs-keyword">constructor</span> <span class="hljs-comment">// true</span>
<span class="hljs-comment">// foo本身是没有constructor属性的，但是foo._proto_指向的原型中有。</span></pre></td>
            </tr>
          </tbody>
        </table>
      </div>
    <blockquote>
<p>来张图解释下
<img src="https://github.com/zChanges/zChange_blog/blob/master/image/js/prototype.png?raw=true" alt="prototype.png-19.2kB"></p>
<p>终极图</p>
</blockquote>
<p><img src="https://github.com/zChanges/zChange_blog/blob/master/image/js/jsobj.jpg?raw=true" alt="jsobj.jpg-99.1kB"></p>
</div>

  
  <div class="label">
    
    <div><a href="\tags\832148399\">#js基础</a></div>
    
  </div>
  

  <div class="relate">
    

    
  </div>
</div>


<div class="footer">
  <div class="center">
    &copy; 2018 zChange .
    <a target="_blank" href="https://github.com/acyortjs/acyort">Powered by Github | AcyOrt</a> .
    <a target="_blank" href="https://github.com/zChanges/zChange_blog/issues">Source</a>
    <sup> 0</sup>
  </div>
</div>





</body>
</html>
